 AS V1.42 Beta [Bld 172] - Source File blink2.olasm - Page 1 - 10/29/2020 11:20:32


       1/       0 :                     ; generated by lcc-xr18CX $Version: 5.2 - XR18CX $ on Thu Oct 29 11:20:32 2020
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 
       4/       0 : =0EH                memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =0FH                retVal:	equ	15
       7/       0 : =0CH                regArg1: equ	12
       8/       0 : =0DH                regArg2: equ	13
(1) 1159/       0 :                     	listing	on
(1) 1160/       0 : C0 00 F1            	lbr	lcc1802init
(1) 1161/       3 :                     	
(1) 1162/       3 :                     
      11/       3 :                     	listing on
      12/       3 : (MACRO)             	orgd
      13/       3 :                     _PIN4:
      14/       3 : 00                  	db 0
      15/       4 : (MACRO)             	orgc
      16/       4 :                     ;;function_start _mysetqOn void function(void)
      17/       4 :                     _mysetqOn:		
      18/       4 :                     ;void mysetqOn(){
      19/       4 :                     ;	asm("	seq\n");
      20/       4 : 7B                  	seq
      21/       5 :                     ;}
      22/       5 :                     L1:
      23/       5 : (MACRO)             	Cretn
      24/       6 :                     
      25/       6 :                     ;;function_end$$ _mysetqOn
      26/       6 :                     ;;function_start _main void function(void)
      27/       6 :                     _main: 
      28/       6 : (MACRO)             	reserve 6
      29/       C :                     ;{
      30/       C :                     ;	unsigned char flippy=0;
      31/       C : (MACRO)             	ldA2 R11,'O',sp,(5+1)
      32/      14 : (MACRO)             	str1I 0,R11
      33/      17 :                     ;D*E*A*D  R11
      34/      17 : C0 00 4A            	lbr L5
      35/      1A :                     L4:
      36/      1A :                     ;	while(1){
      37/      1A :                     ;		setqOn();
      38/      1A : (MACRO)             	Ccall _setqOn
      39/      1D :                     ;		delay(250);
      40/      1D : (MACRO)             	ldaD R12,250
      41/      23 : (MACRO)             	Ccall _delay
      42/      26 :                     ;		setqOff();
      43/      26 : (MACRO)             	Ccall _setqOff
      44/      29 :                     ;		delay(250);
      45/      29 : (MACRO)             	ldaD R12,250
      46/      2F : (MACRO)             	Ccall _delay
      47/      32 :                     ;		setqOn();
      48/      32 : (MACRO)             	Ccall _setqOn
      49/      35 :                     ;		delay(250);
      50/      35 : (MACRO)             	ldaD R12,250
      51/      3B : (MACRO)             	Ccall _delay
      52/      3E :                     ;		setqOff();
      53/      3E : (MACRO)             	Ccall _setqOff
      54/      41 :                     ;		delay(1000);
      55/      41 : (MACRO)             	ldaD R12,1000
      56/      47 : (MACRO)             	Ccall _delay
      57/      4A :                     ;	}
      58/      4A :                     L5:
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm - Page 2 - 10/29/2020 11:20:32


      59/      4A :                     ;	while(1){
      60/      4A : C0 00 1A            	lbr L4
      61/      4D :                     ;}
      62/      4D :                     L3:
      63/      4D : (MACRO)             	release 6
      64/      53 : (MACRO)             	Cretn
      65/      54 :                     
      66/      54 :                     ;;function_end$$ _main
      67/      54 :                     ;;function_start _delay void function(unsigned int)
      68/      54 :                     _delay:		
      69/      54 : (MACRO)             	pushr R6
      70/      58 : (MACRO)             	pushr R7
      71/      5C : (MACRO)             	reserve 4
      72/      60 : (MACRO)             	cpy2 R7,R12
      73/      64 :                     ;void delay(unsigned int howlong){
      74/      64 :                     ;	for (i=1;i!=howlong;i++){
      75/      64 : (MACRO)             	ldaD R6,1
      76/      6A : C0 00 71            	lbr L11
      77/      6D :                     L8:
      78/      6D :                     ;		oneMs();
      79/      6D : (MACRO)             	Ccall _oneMs
      80/      70 :                     ;	}
      81/      70 :                     L9:
      82/      70 :                     ;	for (i=1;i!=howlong;i++){
      83/      70 : (MACRO)             	incm R6,1
      84/      71 :                     L11:
      85/      71 : (MACRO)             	jneU2 R6,R7,L8
      86/      83 :                     ;}
      87/      83 :                     L7:
      88/      83 : (MACRO)             	release 4
      89/      87 : (MACRO)             	popr R7
      90/      8C : (MACRO)             	popr R6
      91/      91 : (MACRO)             	Cretn
      92/      92 :                     
      93/      92 :                     ;;function_end$$ _delay
      94/      92 :                     ;;function_start _olduinoincluder void function(void)
      95/      92 :                     _olduinoincluder:		
      96/      92 :                     ;void olduinoincluder(){
      97/      92 :                     ;	asm("\tinclude olduino.inc\n");
      98/      92 :                     	include olduino.inc
(1)    1/      92 :                     ;Feb 8 2013, first version of assembler routines for olduino support	
(1)    2/      92 :                     ;may 31 - incredibly, there's an error in digitalWrite.  lda2 changed to ldAD
(1)    3/      92 :                     ;Feb 5 2018 changing temp label + in _digitalRead to $$skp, separating label from macro
(1)    4/      92 :                     ;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
(1)    5/      92 :                     	align 64	;needed to make sure all on same page
(1)    6/      C0 :                     _digitalWrite:
(1)    7/      C0 : 8C                  	glo regArg1	;get the bit number
(1)    8/      C1 : FC DF               	adi $$bvtable&255	;add the table offset
(1)    9/      C3 : AE                  	plo memaddr
(1)   10/      C4 : 93                  	ghi RPC		;get the top byte of the current page
(1)   11/      C5 : BE                  	phi memaddr	
(1)   12/      C6 : 0E                  	ldn memaddr	;pick up the bit pattern
(1)   13/      C7 : A8                  	plo rt1		;save it in a temp
(1)   14/      C8 : (MACRO)             	ldAD memaddr,_PIN4 ;address the current port value
(1)   15/      CE : EE                  	sex memaddr	;prepare to change it
(1)   16/      CF : 8D                  	glo regArg2	;get on/off switch
(1)   17/      D0 : 32 D7               	bz $$setbitoff
(1)   18/      D2 :                     ; here we have the bit pattern in rt1 and we're ready to apply it with OR
(1)   19/      D2 : 88                  	glo rt1		;get the bit value back
(1)   20/      D3 : F1                  	or		;apply it
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm(olduino.inc) - Page 3 - 10/29/2020 11:20:32


(1)   21/      D4 : 5E                  	str memaddr	;and save it
(1)   22/      D5 : 30 DC               	br $$outit	;go fnish up
(1)   23/      D7 :                     $$setbitoff:
(1)   24/      D7 : 88                  	glo rt1		;get the bit pattern
(1)   25/      D8 : FB FF               	xri 0xff	;reverse it
(1)   26/      DA : F2                  	and		;combine it with the existing pin value
(1)   27/      DB : 5E                  	str memaddr	;and save it
(1)   28/      DC :                     ;here we gave set/reset the correct bit in PIN4 and we just have to send it out
(1)   29/      DC :                     $$outit:
(1)   30/      DC : 64                  	out 4		;X was already set to memaddr
(1)   31/      DD : E2                  	sex sp		;reset X
(1)   32/      DE : (MACRO)             	cretn
(1)   33/      DF : 01 02 04 08 10 20   $$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
               E5 : 40 80             
(1)   34/      E7 :                     ;int digitalRead(unsigned char pin){//for now this will always read ef3
(1)   35/      E7 :                     	align 8	;protect jump boundary
(1)   36/      E8 :                     _digitalRead:
(1)   37/      E8 : F8 00               	ldi 0		;default is false
(1)   38/      EA : AF                  	plo R15
(1)   39/      EB : BF                  	phi R15
(1)   40/      EC : 36 EF               	b3 $$skp		;i have to reverse the sense of the external line
(1)   41/      EE : 1F                  	inc R15		;if external line is high, supply a 1
(1)   42/      EF :                     $$skp: 
(1)   43/      EF : (MACRO)             	cretn
(1)   44/      F0 :                     
      99/      F0 :                     ;}
     100/      F0 :                     L12:
     101/      F0 : (MACRO)             	Cretn
     102/      F1 :                     
     103/      F1 :                     ;;function_end$$ _olduinoincluder
     104/      F1 :                     	include lcc1802epiloCX.inc
(1)    1/      F1 :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/      F1 :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/      F1 :                     ;this is the version published with the lcc1802121229 release
(1)    4/      F1 :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/      F1 :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/      F1 :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/      F1 :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/      F1 :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/      F1 :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/      F1 :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/      F1 :                     ;feb 27 changed stack to start at 7fff
(1)   12/      F1 :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/      F1 :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/      F1 :                     ;april 4 adding digit count argument to dubdabx
(1)   15/      F1 :                     ;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
(1)   16/      F1 :                     ;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
(1)   17/      F1 :                     ;16-09-20 allow stack relocation 
(1)   18/      F1 :                     ;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
(1)   19/      F1 :                     ;17-03-07 adjusting stack offset for 1805/6 stack discipline
(1)   20/      F1 :                     ;17-03-13 protecting work areas in divi2,divi4 routines from 1806 SCAL
(1)   21/      F1 :                     ;17-03-15 onems compensates for reduced subroutine overhead in 1806
(1)   22/      F1 :                     ;17-04-09 don't include call/return for 1806
(1)   23/      F1 :                     ;17-10-17 SCRT routines changed to clean stack model i.e. push is stxd stxd, pop is inc lda inc ldn
(1)   24/      F1 :                     ;17-10-19 using CPUSPEED instead of LCC1802CPUSPEED, also STACKLOC instead of LCCSTACKLOC
(1)   25/      F1 :                     ;17-10-23 extending work area protection from 10-13 above for 1802 as well as 1805
(1)   26/      F1 : =0EH                rwork:	equ	memAddr	;work register
(1)   27/      F1 :                     ;17-11-25 conditional include for register saves
(1)   28/      F1 :                     ;18-01-28 changed onems() to always use 4 instruction loop, accommodate slower CPU speed
(1)   29/      F1 :                     ;20-04-28 specific version for COMX-35/Crosslib
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm(lcc1802epiloCX.inc) - Page 4 - 10/29/2020 11:20:32


(1)   30/      F1 :                     ;20-04-29 saving registers for COMX basic
(1)   31/      F1 :                     ;20-04-30 changing init for COMX - saving R4&5, using my own SCRT routines.
(1)   32/      F1 :                     ;20-05-01 saving D around Call/return
(1)   33/      F1 :                     ;20-05-18 added sex r2 in SCRT return routine
(1)   34/      F1 :                     ;20-05-23 align for dubdabx - really should move to nstdlib.inc
(1)   35/      F1 :                     ;20-06-19 changed lbr die to br on return from main
(1)   36/      F1 :                     ;20-07-10 (Marcel) added orgc at start to solve issue with branches to data area (suggested by Bill)
(1)   37/      F1 :                     ;20-08-01 dubdabx moved to nstdlib.inc
(1)   38/      F1 : (MACRO)              orgc
(1)   39/      F1 :                     ;;function_start lcc1802init.inc void function(void)
(1)   40/      F1 :                     lcc1802init:
(1)   41/      F1 : =>UNDEFINED           IFDEF SAVEREGS
(1)   42/      F1 :                         include "saveregs.inc"
(1)   43/      F1 : [41]                  ENDIF
(1)   44/      F1 : =>UNDEFINED           IFDEF LCCCX			;wjr 20-04-28 setup for COMX - don't set stack or PC, return to BASIC at end
(1)   45/      F1 :                       	pushr 4
(1)   46/      F1 :                       	pushr 5
(1)   47/      F1 :                       	pushr 7			;wjr 20-04-29 save/restore BASIC registers
(1)   48/      F1 :                       	pushr 9	
(1)   49/      F1 :                       	pushr 11
(1)   50/      F1 :                       	pushr 15
(1)   51/      F1 :                     	ldiReg	RCALL,_call
(1)   52/      F1 :                     	ldiReg	RRET,_return
(1)   53/      F1 :                       	Ccall _main		;wjr 20-04-28 start the C program
(1)   54/      F1 :                       	popr  15		;wjr 20-04-29 save/restore BASIC registers
(1)   55/      F1 :                       	popr  11
(1)   56/      F1 :                       	popr  9
(1)   57/      F1 :                       	popr  7
(1)   58/      F1 :                       	popr 5
(1)   59/      F1 :                       	popr 4
(1)   60/      F1 :                       	Cretn			;wjr 20-04-28 hopefully back to COMX Basic
(1)   61/      F1 : =>TRUE                ELSE
(1)   62/      F1 : =>TRUE                IF    MOMCPU<>$1805		;for 1806 use SCAL 
(1)   63/      F1 : (MACRO)             	ldiReg	RCALL,_call
(1)   64/      F7 : (MACRO)             	ldiReg	RRET,_return
(1)   65/      FD : =>FALSE               ELSE
(1)   66/      FD :                     	ldiReg	RCALL,$$_die; _call
(1)   67/      FD :                     	ldiReg	RRET,$$_die; _return
(1)   68/      FD : [62]                  ENDIF
(1)   69/      FD : =>UNDEFINED         	  IFNDEF  STACKLOC		;wjr 16-09-20 allow stack relocation
(1)   70/      FD : (MACRO)             		ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1 as default
(1)   71/     103 : =>FALSE             	  ELSEIF				;wjr 16-09-20
(1)   72/     103 :                     		ldiReg	SP,STACKLOC	;wjr 16-09-20 start stack as specified
(1)   73/     103 : [69]                	  ENDIF				;wjr 16-09-20
(1)   74/     103 : E2                  		sex	SP
(1)   75/     104 : (MACRO)             		ldiReg	RPC,$$_00000
(1)   76/     10A : D3                  		sep	RPC
(1)   77/     10B :                     	$$_00000:
(1)   78/     10B : (MACRO)             		Ccall _main	;call the main routine
(1)   79/     10E : 30 0E               	$$_die:	br	$$_die		;loop here when main returns
(1)   80/     110 : DE AD               		db	0xde,0xad
(1)   81/     112 : [44]                  ENDIF
(1)   82/     112 :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   83/     112 :                     _setqOn:
(1)   84/     112 : 7B                  	seq
(1)   85/     113 : (MACRO)             	Cretn
(1)   86/     114 :                     _setqOff:
(1)   87/     114 : 7A                  	req
(1)   88/     115 : (MACRO)             	Cretn
(1)   89/     116 : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm(lcc1802epiloCX.inc) - Page 5 - 10/29/2020 11:20:32


(1)   90/     116 :                     _modU2:	;16 bit unsigned remainder
(1)   91/     116 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   92/     116 : (MACRO)                 Ccall _divU2
(1)   93/     119 : 8C                      glo regArg1
(1)   94/     11A : AF                      plo retVal
(1)   95/     11B : 9C                      ghi regArg1
(1)   96/     11C : BF                      phi retVal
(1)   97/     11D : (MACRO)                 Cretn
(1)   98/     11E :                         
(1)   99/     11E :                     _modI2:	;16 bit signed remainder
(1)  100/     11E :                     	; just calls the 16 bit division then puts remainder into return value
(1)  101/     11E : (MACRO)                 Ccall _divI2
(1)  102/     121 : 8C                      glo regArg1
(1)  103/     122 : AF                      plo retVal
(1)  104/     123 : 9C                      ghi regArg1
(1)  105/     124 : BF                      phi retVal
(1)  106/     125 : (MACRO)                 Cretn
(1)  107/     126 : [89]                 ENDIF
(1)  108/     126 :                     _out4:	
(1)  109/     126 : 8C                  	glo	regArg1
(1)  110/     127 : 22                  	dec	sp
(1)  111/     128 : 52                  	str	sp
(1)  112/     129 : 64                  	out	4
(1)  113/     12A : (MACRO)             	Cretn
(1)  114/     12B :                     
(1)  115/     12B :                     ;the following routines have short branches so all the code has to stay within the same page
(1)  116/     12B : =>TRUE                if MOMCPU<>$1805		;for 1806 use SCAL
(1)  117/     12B :                     	align 32
(1)  118/     140 :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)  119/     140 : D3                  	sep     R3 ;go to subroutine
(1)  120/     141 : E2                  _call:	sex	SP ;make sure X=SP
(1)  121/     142 : =>UNDEFINED           IFDEF LCCCX			;wjr 20-04-28 setup for COMX
(1)  122/     142 :                     	phi	r15	;save D #wjr 20-05-01
(1)  123/     142 : [121]                 ENDIF
(1)  124/     142 : 86                  	glo	retAddr ;save previous return pointer on stack
(1)  125/     143 : 73                  	stxd
(1)  126/     144 : 96                  	ghi	retAddr
(1)  127/     145 : 73                  	stxd	
(1)  128/     146 : 83                  	glo	RPC ;copy old PC to retAddr
(1)  129/     147 : A6                  	plo	retAddr
(1)  130/     148 : 93                  	ghi	RPC
(1)  131/     149 : B6                  	phi	retAddr
(1)  132/     14A : 46                  	lda	retAddr ;pick up subroutine address into RPC
(1)  133/     14B : B3                  	phi	RPC
(1)  134/     14C : 46                  	lda	retAddr
(1)  135/     14D : A3                  	plo	RPC
(1)  136/     14E : =>UNDEFINED           IFDEF LCCCX			;wjr 20-04-28 setup for COMX
(1)  137/     14E :                     	ghi	r15	;save D #wjr 20-05-01
(1)  138/     14E : [136]                 ENDIF
(1)  139/     14E : 30 40               	br	_call-1
(1)  140/     150 :                     
(1)  141/     150 :                     ;Standard subroutine return 
(1)  142/     150 : =>UNDEFINED           IFDEF LCCCX			;wjr 20-04-28 setup for COMX
(1)  143/     150 :                     	align 16
(1)  144/     150 : [142]                 ENDIF
(1)  145/     150 : D3                  	sep	RPC	;return to the original program
(1)  146/     151 :                     _return: 
(1)  147/     151 : =>UNDEFINED           IFDEF LCCCX			;wjr 20-04-28 setup for COMX
(1)  148/     151 :                     	phi	r15	;save D #wjr 20-05-01
(1)  149/     151 :                             sex r2		;fix x register per marcel
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm(lcc1802epiloCX.inc) - Page 6 - 10/29/2020 11:20:32


(1)  150/     151 : [147]                 ENDIF
(1)  151/     151 : 86                  	glo	retAddr	;transfer the current return address to RPC
(1)  152/     152 : A3                  	plo	RPC
(1)  153/     153 : 96                  	ghi	retAddr
(1)  154/     154 : B3                  	phi	RPC
(1)  155/     155 : 12                  	inc 	SP
(1)  156/     156 : 42                  	lda	SP	;pick up old return address
(1)  157/     157 : B6                  	phi	retAddr
(1)  158/     158 : 02                  	ldn	SP
(1)  159/     159 : A6                  	plo	retAddr
(1)  160/     15A : =>UNDEFINED           IFDEF LCCCX			;wjr 20-04-28 setup for COMX
(1)  161/     15A :                     	ghi	r15	;save D #wjr 20-05-01
(1)  162/     15A : [160]                 ENDIF
(1)  163/     15A : 30 50               	br	_return-1
(1)  164/     15C : [116]                ENDIF
(1)  165/     15C :                     	align 8
(1)  166/     160 :                     _oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
(1)  167/     160 :                     ;subroutine overhead soaks up 27 instruction time.
(1)  168/     160 :                     ;each loop is 2 instruction times
(1)  169/     160 :                     ;so the number of loops needed is 
(1)  170/     160 :                     ;CPU speed/16000 less the 27 all divide by two
(1)  171/     160 : =>UNDEFINED         	IFNDEF	CPUSPEED
(1)  172/     160 : =186A00H            CPUSPEED EQU 1600000	;1.6MHZ default
(1)  173/     160 : [171]               	ENDIF
(1)  174/     160 : =>FALSE              if MOMCPU=$1805		;for 1806 SCAL
(1)  175/     160 :                     SUBOVHD  EQU 14		;1806 SCAL/SRET subroutine overhead
(1)  176/     160 : =>TRUE               else
(1)  177/     160 : =1BH                SUBOVHD  EQU 27		;default SCRT subroutine overhead
(1)  178/     160 : [174]                endif 
(1)  179/     160 : =>TRUE                    IF (CPUSPEED/16000)>=(SUBOVHD+4);fast enough to need more than subroutine overhead
(1)  180/     160 : F8 12               	ldi	(CPUSPEED/1000/16-SUBOVHD)/4
(1)  181/     162 : FF 01               $$mslf:	smi	1
(1)  182/     164 : E2                  	sex	2
(1)  183/     165 : E2                  	sex	2
(1)  184/     166 : 3A 62               	bnz	$$mslf
(1)  185/     168 : [179]                 ENDIF
(1)  186/     168 : (MACRO)             	Cretn
(1)  187/     169 :                     
(1)  188/     169 :                     
(1)  189/     169 : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math	
(1)  190/     169 :                     	align 256
(1)  191/     200 :                     ;16 bit right shifting multiply which is faster for smaller operands
(1)  192/     200 :                     ; credit to http://map.grauw.nl/articles/mult_div_shifts.php#lrmultr
(1)  193/     200 :                     _mulU2:		;retval(product)=regarg1(multiplicand)*regarg2(multiplier)
(1)  194/     200 : (MACRO)             	ld2z retval
(1)  195/     204 :                     $$mulrlp:
(1)  196/     204 : (MACRO)             	shru2 regarg2
(1)  197/     20A : 3B 16               	bnf $$mulrnoadd
(1)  198/     20C :                     ;	bottom bit of multiplier is one so add multiplicand to product
(1)  199/     20C : (MACRO)             	alu2 retval,retval,regarg1,add,adc
(1)  200/     216 :                     $$mulrnoadd:
(1)  201/     216 : 9D                  	ghi regarg2	;check for all bits of multiplier shifted out
(1)  202/     217 : 3A 1C               	bnz $$mulrshft	;nope, continue
(1)  203/     219 : 8D                  	glo regarg2	;check bottom byte
(1)  204/     21A : 32 24               	bz $$mulrdone
(1)  205/     21C :                     $$mulrshft:
(1)  206/     21C : (MACRO)             	shl2 regarg1	;shift multiplicand left 1
(1)  207/     222 : 30 04               	br $$mulrlp
(1)  208/     224 :                     $$mulrdone:		;here the product is in retval
(1)  209/     224 : (MACRO)             	cretn
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm(lcc1802epiloCX.inc) - Page 7 - 10/29/2020 11:20:32


(1)  210/     225 :                     
(1)  211/     225 :                     ;this is a divisor shifting algorithm which is faster for smaller operands
(1)  212/     225 :                     ;credit to http://research.microsoft.com/pubs/70645/tr-2008-141.pdf
(1)  213/     225 :                     ;changed oct 12 to save R10 & 1/2 R11 on stack
(1)  214/     225 :                     _divu2: ;retval=regarg1(x or dividend)/regarg2(y or divisor)
(1)  215/     225 :                     	;uses R14(rwork) to hold original divisor y0, 
(1)  216/     225 :                     	;regarg1 to hold develop remainder, 
(1)  217/     225 :                     	;R10 to hold working dividend R11.0 as a temp
(1)  218/     225 :                     testsub: macro reg1,reg2	;test subtraction of reg2 from reg1
(1)  219/     225 :                     				;result in D, rwork.hi, DF
(1)  220/     225 :                     	glo reg2
(1)  221/     225 :                     	str sp
(1)  222/     225 :                     	glo reg1
(1)  223/     225 :                     	sm
(1)  224/     225 :                     	plo R11
(1)  225/     225 :                     	ghi reg2
(1)  226/     225 :                     	str sp
(1)  227/     225 :                     	ghi reg1
(1)  228/     225 :                     	smb
(1)  229/     225 :                     	endm
(1)  230/     225 :                     	
(1)  231/     225 :                     ;	pushf R10	;save R10 & leave stack down 1
(1)  232/     225 : (MACRO)             	pushr R10	;default push leaves stack clean
(1)  233/     229 : 8B                  	glo R11		;and bottom
(1)  234/     22A : 73                  	stxd		;of R11 - leaves stack clear of work area
(1)  235/     22B : (MACRO)             	cpy2 R10,regarg1
(1)  236/     22F : (MACRO)             	ld2z retval	;quotient
(1)  237/     233 : (MACRO)             	cpy2 rwork,regarg2
(1)  238/     237 :                     	
(1)  239/     237 : (MACRO)             	testsub R10,regarg2
(1)  240/     240 : 3B 5B               	bnf $$computequot	;DF=0 means it didn't fit
(1)  241/     242 : BA                  	phi R10	;R10=R10-regarg2
(1)  242/     243 : 8B                  	glo R11
(1)  243/     244 : AA                  	plo R10
(1)  244/     245 :                     	
(1)  245/     245 :                     $$again:	;this is the divisor doubling phase
(1)  246/     245 : (MACRO)              	testsub R10,regarg2
(1)  247/     24E : 3B 5B                	bnf $$computequot	;df=0 means it didn't fit
(1)  248/     250 : BA                  	phi R10	;R10=R10-regarg2
(1)  249/     251 : 8B                  	glo R11
(1)  250/     252 : AA                  	plo R10 	
(1)  251/     253 : (MACRO)              	shl2 regarg2	;y=y+y
(1)  252/     259 : 30 45                	br $$again
(1)  253/     25B :                      	
(1)  254/     25B :                      $$computequot:	;here we're computing the quotient
(1)  255/     25B : (MACRO)              	testsub regarg1,regarg2
(1)  256/     264 : 3B 6A                	bnf $$testexit
(1)  257/     266 : BC                   	phi regarg1		;complete the subtraction
(1)  258/     267 : 8B                   	glo R11
(1)  259/     268 : AC                   	plo regarg1
(1)  260/     269 : 1F                   	inc retval
(1)  261/     26A :                      $$testexit:
(1)  262/     26A : 9E                   	ghi rwork
(1)  263/     26B : F7                   	sm	;top of regarg2 is still on stack
(1)  264/     26C : 3A 74                	bnz $$ney0y
(1)  265/     26E : 8D                   	glo regarg2
(1)  266/     26F : 52                   	str sp
(1)  267/     270 : 8E                   	glo rwork
(1)  268/     271 : F7                   	sm	;test low order bytes
(1)  269/     272 : 32 82                	bz	$$out	;if = we're done
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm(lcc1802epiloCX.inc) - Page 8 - 10/29/2020 11:20:32


(1)  270/     274 :                      $$ney0y:
(1)  271/     274 : (MACRO)              	shl2 retval	;double quotient
(1)  272/     27A : (MACRO)              	shrU2 regarg2	;halve divisor
(1)  273/     280 : 30 5B                	br $$computequot	;continue
(1)  274/     282 :                      $$out:
(1)  275/     282 :                      ;here the quotient is in retval, remainder in regarg1
(1)  276/     282 : 12                    	inc sp	;release work area
(1)  277/     283 : 02                  	ldn sp	;recover
(1)  278/     284 : AB                  	plo R11	;bottom byte of R11
(1)  279/     285 : (MACRO)             	popr R10 ;and all of R10
(1)  280/     28A : (MACRO)             	cretn	;and we're done
(1)  281/     28B :                     
(1)  282/     28B :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  283/     28B :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  284/     28B :                     _divI2:
(1)  285/     28B : 22                      dec	sp	;leave a work area available
(1)  286/     28C : 9C                      ghi regArg1
(1)  287/     28D : 52                      str sp	;save the sign of the 1st arg
(1)  288/     28E : FE                      shl
(1)  289/     28F : 3B 9A                   bnf $$pos1	;if the 1st arg is -v
(1)  290/     291 : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
(1)  291/     29A :                     $$pos1: ;1st is now +v, check 2nd
(1)  292/     29A : 9D                      ghi regArg2
(1)  293/     29B : F3                      xor	
(1)  294/     29C : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  295/     29D : 9D                      ghi regArg2
(1)  296/     29E : FE                      shl
(1)  297/     29F : 3B AA                   bnf $$pos2	;if the 2nd arg is -v
(1)  298/     2A1 : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  299/     2AA :                     $$pos2: ; both args now +v
(1)  300/     2AA : 22                      dec sp	;protect workarea on the 1802
(1)  301/     2AB : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  302/     2AE : 12                      inc sp	;recover work area
(1)  303/     2AF :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  304/     2AF : 42                      lda	sp ;get back the sign bits and restore SP
(1)  305/     2B0 : FE                      shl
(1)  306/     2B1 : 3B BC                   bnf $$done ;if the signs were different
(1)  307/     2B3 : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  308/     2BC :                     $$done:
(1)  309/     2BC : (MACRO)                 Cretn ;and we're done - I hope!
(1)  310/     2BD : [189]                ENDIF
(1)  311/     2BD : =>UNDEFINED          IFNDEF  LCCNOLONG		;wjr 17-04-09 disable 32 bit math
(1)  312/     2BD :                     	align 256    ;32 bit operations follow
(1)  313/     300 :                     _divu4:
(1)  314/     300 :                     ;This is an unsigned 32 bit restoring division
(1)  315/     300 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  316/     300 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  317/     300 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  318/     300 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  319/     300 :                     
(1)  320/     300 : F8 20               	ldi 32		;set loop count
(1)  321/     302 : AE                  	plo memaddr	;in temp register
(1)  322/     303 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  323/     30F :                     $$loop:
(1)  324/     30F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  325/     31B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  326/     327 :                     
(1)  327/     327 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  328/     33D :                     
(1)  329/     33D : FA 80               	ani 0x80	;check the top bit
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm(lcc1802epiloCX.inc) - Page 9 - 10/29/2020 11:20:32


(1)  330/     33F : 32 5D               	bz $$norestore	;if it's 0
(1)  331/     341 : 89                  		glo RL8
(1)  332/     342 : FA FE               		ani 0xfe	;turn off the bottom bit
(1)  333/     344 : A9                  		plo RL8
(1)  334/     345 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  335/     35B : 30 61               	br $$endlp 	;else
(1)  336/     35D :                     $$norestore:
(1)  337/     35D : 89                  		glo RL8
(1)  338/     35E : F9 01               		ori 1	;turn on the bottom bit
(1)  339/     360 : A9                  		plo RL8
(1)  340/     361 :                     	;end if
(1)  341/     361 :                     $$endlp:
(1)  342/     361 : 2E                  	dec memaddr	;check the cycle count
(1)  343/     362 : 8E                  	glo memaddr
(1)  344/     363 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  345/     365 :                     	
(1)  346/     365 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  347/     366 :                     		
(1)  348/     366 :                     
(1)  349/     366 :                     _mulu4:
(1)  350/     366 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  351/     366 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  352/     366 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  353/     366 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  354/     366 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  355/     366 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  356/     366 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  357/     366 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  358/     366 :                     	;for 10 we subtract and shift
(1)  359/     366 :                     	;for 00 and 11 we just shift
(1)  360/     366 :                     
(1)  361/     366 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  362/     372 : F8 20                   ldi 32
(1)  363/     374 : AE                      plo memaddr		;cycle count
(1)  364/     375 : FC 00                   adi 0		;clear df
(1)  365/     377 :                     $$mloop:
(1)  366/     377 : 89                      glo RL8
(1)  367/     378 : FA 01                   ani 1		;isolate bottom bit of result
(1)  368/     37A : 3B 96                   bnf	$$check_sub	;
(1)  369/     37C : 3A AE                   bnz	$$shift		;that would be the 11 case
(1)  370/     37E :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  371/     37E : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  372/     394 : 30 AE                   br $$shift
(1)  373/     396 :                     $$check_sub:
(1)  374/     396 : 32 AE                   bz $$shift	;that would be the 00 case
(1)  375/     398 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  376/     398 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  377/     3AE :                     $$shift:
(1)  378/     3AE : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  379/     3BC : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  380/     3C8 :                     
(1)  381/     3C8 : 2E                      dec memaddr		;cycle count
(1)  382/     3C9 : 8E                      glo memaddr
(1)  383/     3CA : 3A 77                   bnz $$mloop		;repeat cycle once for each bit position
(1)  384/     3CC :                         
(1)  385/     3CC : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  386/     3CD :                     
(1)  387/     3CD :                     	align 256
(1)  388/     400 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  389/     400 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm(lcc1802epiloCX.inc) - Page 10 - 10/29/2020 11:20:32


(1)  390/     400 :                     _divI4:
(1)  391/     400 : 22                      dec	sp	;leave a work area available
(1)  392/     401 : 98                      ghi RL8-1	;get the top of the dividend
(1)  393/     402 : 52                      str sp	;save the sign of the 1st arg
(1)  394/     403 : FE                      shl
(1)  395/     404 : 3B 26                   bnf $$pos1	;if the 1st arg is -v
(1)  396/     406 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  397/     426 :                     $$pos1: ;1st is now +v, check 2nd
(1)  398/     426 : 9A                      ghi RL10-1
(1)  399/     427 : F3                      xor	
(1)  400/     428 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  401/     429 : 9A                      ghi RL10-1
(1)  402/     42A : FE                      shl
(1)  403/     42B : 3B 4D                   bnf $$pos2	;if the 2nd arg is -v
(1)  404/     42D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  405/     44D :                     $$pos2: ; both args now +v
(1)  406/     44D : 22                      dec sp	;protect workarea on the 1802
(1)  407/     44E : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  408/     451 : 12                      inc sp	;recover work area
(1)  409/     452 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  410/     452 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  411/     453 : FE                      shl
(1)  412/     454 : 3B 76                   bnf $$done ;if the signs were different
(1)  413/     456 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  414/     476 :                     $$done:
(1)  415/     476 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  416/     477 : [311]                ENDIF
(1)  417/     477 : =>UNDEFINED          IFNDEF  LCCNOLONG		;wjr 17-04-09 disable 32 bit math	
(1)  418/     477 :                     _modU4:	;32 bit unsigned remainder
(1)  419/     477 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  420/     477 : (MACRO)                 Ccall _divU4
(1)  421/     47A : (MACRO)                 cpy4 RL8,Rp1p2
(1)  422/     482 : (MACRO)                 Cretn
(1)  423/     483 :                         
(1)  424/     483 :                     _modI4:	;32 bit signed remainder
(1)  425/     483 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  426/     483 : (MACRO)                 Ccall _divI4
(1)  427/     486 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  428/     48E : (MACRO)                 Cretn
(1)  429/     48F : [417]                ENDIF	
(1)  430/     48F :                     ;;function_end lcc1802init.inc
(1)  431/     48F :                     
     105/     48F :                     	include IO1802.inc
(1)    1/     48F :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/     48F :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/     48F :                     ;18-02-23 changed label + to $$no0 in _inp: to eliminate this style of temporary
(1)    4/     48F :                     	align 64
(1)    5/     4C0 :                     ;;function_start IO1802.inc void function(void)
(1)    6/     4C0 :                     _putc:
(1)    7/     4C0 :                     _out5:	
(1)    8/     4C0 : 8C                  	glo	regArg1
(1)    9/     4C1 : 22                  	dec	sp
(1)   10/     4C2 : 52                  	str	sp
(1)   11/     4C3 : 65                  	out	5
(1)   12/     4C4 : (MACRO)             	Cretn
(1)   13/     4C5 :                     _inp:		;raw port input
(1)   14/     4C5 :                     		;stores a small tailored program on the stack and executes it
(1)   15/     4C5 : 22                  	dec	sp	;work backwards
(1)   16/     4C6 : F8 D3               	ldi	0xD3	;return instruction
(1)   17/     4C8 : 73                  	stxd		
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm(IO1802.inc) - Page 11 - 10/29/2020 11:20:32


(1)   18/     4C9 : 8C                  	glo	regarg1	;get the port number
(1)   19/     4CA : FA 07               	ani	0x07	;clean it
(1)   20/     4CC : 32 DC               	bz	$$no0	; inp(0) isn't valid
(1)   21/     4CE : F9 68               	ori	0x68	;make it an input instruction
(1)   22/     4D0 : 73                  	stxd		;store it for execution
(1)   23/     4D1 : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   24/     4D5 : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   25/     4D6 : D8                  	sep	rt1	;execute it
(1)   26/     4D7 :                     ;we will come back to here with the input byte in D
(1)   27/     4D7 : 12                  	inc	sp	;step over the work area
(1)   28/     4D8 : AF                  	plo	retVal	;save it to return
(1)   29/     4D9 : F8 00               	ldi	0
(1)   30/     4DB : BF                  	phi	retval	;clear top byte
(1)   31/     4DC : 12                  $$no0	inc	sp	;need to get rid of the 6x instruction
(1)   32/     4DD : 12                  	inc	sp	;and the D3
(1)   33/     4DE : (MACRO)             	Cretn		;and we're done
(1)   34/     4DF :                     	
(1)   35/     4DF :                     _out:		;raw port output
(1)   36/     4DF :                     		;stores a small tailored program on the stack and executes it
(1)   37/     4DF :                     		;this could be bolder:
(1)   38/     4DF :                     		;store the program as 6x cc D5 where x is the port number and cc is the char
(1)   39/     4DF :                     		;then SEP sp
(1)   40/     4DF :                     		;the D5 would return to the calling program and finish fixing the stack.
(1)   41/     4DF :                     		;saves 6 instructions but it's a bit tricky.
(1)   42/     4DF : 22                  	dec	sp	;work backwards
(1)   43/     4E0 : F8 D3               	ldi	0xD3	;return instruction
(1)   44/     4E2 : 73                  	stxd		
(1)   45/     4E3 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the OUT instruction
(1)   46/     4E7 : 8C                  	glo	regarg1	;get the port number
(1)   47/     4E8 : FA 07               	ani	0x07	;clean it
(1)   48/     4EA : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   49/     4EC : 73                  	stxd		;store it for execution
(1)   50/     4ED : 8D                  	glo	regarg2	;get the byte to be written
(1)   51/     4EE : 52                  	str	sp	;store it where sp points
(1)   52/     4EF : D8                  	sep	rt1	;execute it
(1)   53/     4F0 :                     ;we will come back to here with sp stepped up by one
(1)   54/     4F0 : 12                  	inc	sp	;need to get rid of the 6x instruction
(1)   55/     4F1 : 12                  	inc	sp	;and the D3
(1)   56/     4F2 : (MACRO)             	Cretn		;and we're done
(1)   57/     4F3 :                     ;;function_end IO1802.inc
(1)   58/     4F3 :                     
(1)   59/     4F3 :                     	
(1)   60/     4F3 :                     	
(1)   61/     4F3 :                     
     106/     4F3 :                     	include LCC1802finale.inc
(1)    1/     4F3 :                     ;LCC1802finale.inc is the last code processed by the assembler
(1)    2/     4F3 :                     ;20-05-23 finale used to include comx/comx_final.inc with  comx load feature
(1)    3/     4F3 :                     ;20-06-11 renamed to basic_final to reflect this is a final addition to add BASIC routine
(1)    4/     4F3 :                     
(1)    5/     4F3 : =>UNDEFINED           IFDEF LCCCX
(1)    6/     4F3 :                         include devkit/system/basic_final.inc
(1)    7/     4F3 : [5]                   ENDIF
     107/     4F3 :                     
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm - Page 12 - 10/29/2020 11:20:32


  Symbol Table (* = unused):
  --------------------------

 AGAIN70 :                      245 C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
*BIGENDIAN :                      0 - | *BRANCHEXT :                      0 - |
 BVTABLE54 :                    0DF C | *CASESENSITIVE :                  0 - |
 CHECK_SUB73 :                  396 C |  CODELOC :                        0 - |
 COMPUTEQUOT70 :                25B C | *CONSTPI :        3.141592653589793 - |
 CPUSPEED :                  186A00 - | *CSEG :                           1 - |
*DATE :                "10/29/2020" - |  DONE71 :                       2BC C |
 DONE74 :                       476 C |  ENDLP72 :                      361 C |
*FALSE :                          0 - | *FULLPMMU :                       1 - |
*HAS64 :                          0 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - | *INSRCMODE :                      0 - |
*INSUPMODE :                      0 - | *L1 :                             5 C |
 L11 :                           71 C | *L12 :                          0F0 C |
*L3 :                            4D C |  L4 :                            1A C |
 L5 :                            4A C | *L7 :                            83 C |
 L8 :                            6D C | *L9 :                            70 C |
 LCC1802INIT :                  0F1 C | *LISTON :                         1 - |
 LOOP72 :                       30F C | *MACEXP :                         7 - |
 MEMADDR :                       0E - |  MLOOP73 :                      377 C |
 MOMCPU :                      1802 - | *MOMCPUNAME :                "1802" - |
 MSLF68 :                       162 C |  MULRDONE69 :                   224 C |
 MULRLP69 :                     204 C |  MULRNOADD69 :                  216 C |
 MULRSHFT69 :                   21C C | *NESTMAX :                      100 - |
 NEY0Y70 :                      274 C |  NO079 :                        4DC C |
 NORESTORE72 :                  35D C |  OUT70 :                        282 C |
 OUTIT54 :                      0DC C | *PACKING :                        0 - |
*PADDING :                        1 - |  POS171 :                       29A C |
 POS174 :                       426 C |  POS271 :                       2AA C |
 POS274 :                       44D C | *R0 :                             0 - |
*R1 :                             1 - |  R10 :                           0A - |
 R11 :                           0B - |  R12 :                           0C - |
*R13 :                           0D - | *R14 :                           0E - |
 R15 :                           0F - | *R2 :                             2 - |
 R3 :                             3 - | *R4 :                             4 - |
*R5 :                             5 - |  R6 :                             6 - |
 R7 :                             7 - | *R8 :                             8 - |
*R9 :                             9 - |  RCALL :                          4 - |
 REGARG1 :                       0C - |  REGARG2 :                       0D - |
*RELAXED :                        1 - |  RETADDR :                        6 - |
 RETVAL :                        0F - | *RL0 :                            1 - |
 RL10 :                          0B - | *RL12 :                          0D - |
*RL6 :                            7 - |  RL8 :                            9 - |
 RP1P2 :                         0D - |  RPC :                            3 - |
 RRET :                           5 - |  RT1 :                            8 - |
*RT2 :                            9 - |  RWORK :                         0E - |
 SETBITOFF54 :                  0D7 C |  SHIFT73 :                      3AE C |
 SKP55 :                        0EF C |  SP :                             2 - |
 SUBOVHD :                       1B - |  TESTEXIT70 :                   26A C |
*TIME :                  "11:20:32" - | *TRUE :                           1 - |
 VERSION :                     142F - | *Z80SYNTAX :                      0 - |
 _0000058 :                     10B C |  _CALL :                        141 C |
 _DELAY :                        54 C |  _DIE58 :                       10E C |
*_DIGITALREAD :                 0E8 C | *_DIGITALWRITE :                0C0 C |
 _DIVI2 :                       28B C |  _DIVI4 :                       400 C |
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm - Page 13 - 10/29/2020 11:20:32


 _DIVU2 :                       225 C |  _DIVU4 :                       300 C |
*_INP :                         4C5 C |  _MAIN :                          6 C |
*_MODI2 :                       11E C | *_MODI4 :                       483 C |
*_MODU2 :                       116 C | *_MODU4 :                       477 C |
*_MULU2 :                       200 C | *_MULU4 :                       366 C |
*_MYSETQON :                      4 C | *_OLDUINOINCLUDER :              92 C |
 _ONEMS :                       160 C | *_OUT :                         4DF C |
*_OUT4 :                        126 C | *_OUT5 :                        4C0 C |
 _PIN4 :                          3 C | *_PUTC :                        4C0 C |
 _RETURN :                      151 C |  _SETQOFF :                     114 C |
 _SETQON :                      112 C |

    133 symbols
     61 unused symbols

 AS V1.42 Beta [Bld 172] - Source File blink2.olasm - Page 14 - 10/29/2020 11:20:32


  Defined Macros:
  ---------------

ALU1                                  | ALU2                                 
ALU2I                                 | ALU2RRS                              
ALU4                                  | ALU4I                                
BLKCPY                                | CCALL                                
CCALLD                                | CPY1                                 
CPY2                                  | CPY4                                 
CRETN                                 | DECM                                 
DEMOTE                                | GLOBSS                               
INC4                                  | INCM                                 
JCF4                                  | JCI1I                                
JCI2                                  | JCI2I                                
JCI4                                  | JCU1                                 
JCU2                                  | JCU2I                                
JCU4                                  | JEQI1                                
JEQI2                                 | JEQI4                                
JEQU1I                                | JEQU2I                               
JNEU1                                 | JNEU1I                               
JNEU2                                 | JNEU2I                               
JNEU2NI                               | JNEU4                                
JNI2I                                 | JNU2I                                
JNZU1                                 | JNZU2                                
JUMPV                                 | JZU1                                 
JZU2                                  | LD1                                  
LD2                                   | LD2Z                                 
LD4                                   | LDA2                                 
LDAD                                  | LDAX                                 
LDAXS                                 | LDI4                                 
LDIREG                                | LDN1                                 
LDN2                                  | LDN2S                                
MVC1                                  | MVC2                                 
MVCN1                                 | MVCN2                                
NEGI2                                 | NEGI4                                
NOP1806                               | ORGC                                 
ORGD                                  | POPF                                 
POPL                                  | POPM                                 
POPR                                  | PUSHF                                
PUSHL                                 | PUSHM                                
PUSHR                                 | RELEASE                              
RELEASEL                              | RELEASES                             
RESERVE                               | RESERVEL                             
RESERVES                              | SEXT                                 
SEXT4                                 | SHL2                                 
SHL2I                                 | SHL2R                                
SHL4                                  | SHL4I                                
SHL4R                                 | SHLC4                                
SHLR2R                                | SHRC4                                
SHRI2                                 | SHRI2I                               
SHRI2R                                | SHRI4                                
SHRI4I                                | SHRI4R                               
SHRU2                                 | SHRU2I                               
SHRU2R                                | SHRU4                                
SHRU4I                                | SHRU4R                               
ST1                                   | ST2                                  
ST2I                                  | ST4                                  
STR1                                  | STR1I                                
STR2                                  | STR2I                                
TESTSUB                               | ZEXT                                 
 AS V1.42 Beta [Bld 172] - Source File blink2.olasm - Page 15 - 10/29/2020 11:20:32


ZEXT4                                 |

    115 macros

 AS V1.42 Beta [Bld 172] - Source File blink2.olasm - Page 16 - 10/29/2020 11:20:32


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.05 seconds assembly time

   1812 lines source file
   3037 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
